#!/usr/bin/env bash

tmp_dir="/tmp/cliphist"

# Copy function that removes old entries and puts selected item at top of clipboard history
copy_clipboard_content() {
    local content="$1"
    local id="$2"
    local content_to_copy=""
    
    # Strip whitespace (the key fix we discovered)
    content=$(echo -n "$content" | tr -d '\r\n')
    
    # Determine what we would copy
    if [[ "$content" =~ ^file://(.+\.(jpg|jpeg|png|bmp|gif|webp|tiff|svg))$ ]]; then
        content_to_copy="$content"
    elif [[ "$content" =~ ^(.+\.(jpg|jpeg|png|bmp|gif|webp|tiff|svg))$ ]]; then
        local filepath="$HOME/${content}"
        if [[ -f "$filepath" ]]; then
            content_to_copy="file://$filepath"
        else
            content_to_copy="$content"
        fi
    elif [[ "$content" =~ ^\[\[.*binary.*data.*(image|jpg|jpeg|png|bmp|gif|webp|tiff|svg) ]]; then
        # Binary image data from browsers
        content_to_copy="$content"
    else
        content_to_copy="$content"
    fi

    # Now copy the content (will appear at top of history)
    if [[ "$content" =~ ^\[\[.*binary.*data.*(image|jpg|jpeg|png|bmp|gif|webp|tiff|svg) ]]; then
        # Binary image data from browsers - save to temp file and copy as file URL
        local ext="png"  # default
        if [[ "$content" =~ image/jpeg|jpeg|jpg ]]; then
            ext="jpg"
        elif [[ "$content" =~ image/png|png ]]; then
            ext="png"
        elif [[ "$content" =~ image/gif|gif ]]; then
            ext="gif"
        elif [[ "$content" =~ image/bmp|bmp ]]; then
            ext="bmp"
        elif [[ "$content" =~ image/webp|webp ]]; then
            ext="webp"
        elif [[ "$content" =~ image/tiff|tiff ]]; then
            ext="tiff"
        elif [[ "$content" =~ image/svg|svg ]]; then
            ext="svg"
        fi
        
        local temp_file="$tmp_dir/clipboard_image_$(date +%s).$ext"
        mkdir -p "$tmp_dir"
        echo -n "$id" | cliphist decode > "$temp_file"
        
        if [[ -f "$temp_file" ]]; then
            # Copy as file URL so applications recognize it as an image file
            echo -n "file://$temp_file" | wl-copy --type "text/uri-list"
        else
            # Fallback to raw binary if file creation failed
            echo -n "$id" | cliphist decode | wl-copy
        fi
    elif [[ "$content" =~ ^file://(.+\.(jpg|jpeg|png|bmp|gif|webp|tiff|svg))$ ]]; then
        # Copy the file URI in the format that file managers and Discord expect
        echo -n "$content" | wl-copy --type "text/uri-list"
    elif [[ "$content" =~ ^(.+\.(jpg|jpeg|png|bmp|gif|webp|tiff|svg))$ ]]; then
        local filepath="$HOME/${content}"
        if [[ -f "$filepath" ]]; then
            echo -n "file://$filepath" | wl-copy --type "text/uri-list"
        else
            echo -n "$content" | wl-copy
        fi
    else
        # Default: copy as-is (text or binary)
        echo -n "$content" | wl-copy
    fi
    
    # Handle duplicate removal based on content type
    if [[ "$content" =~ ^\[\[.*binary.*data.*(image|jpg|jpeg|png|bmp|gif|webp|tiff|svg) ]]; then
        # Always delete the original binary entry since we converted it to a file URL
        echo "$id" | cliphist delete
    elif [[ "$content" =~ ^file://(.+\.(jpg|jpeg|png|bmp|gif|webp|tiff|svg))$ ]] || 
         [[ "$content" =~ ^(.+\.(jpg|jpeg|png|bmp|gif|webp|tiff|svg))$ && -f "$HOME/${content}" ]]; then
        # For file URLs (including converted browser images), always delete the OLD entry we selected
        # The new entry was just created at the top by wl-copy
        echo "$id" | cliphist delete
    fi
}

# If argument provided, decode and copy
if [[ -n "$1" ]]; then
    # Extract ID if it's a full line, otherwise use as-is
    if [[ "$1" =~ ^([0-9]+) ]]; then
        id="${BASH_REMATCH[1]}"
    else
        id="$1"
    fi
    # Get the description from cliphist list for pattern matching
    description=$(cliphist list | grep "^$id" | cut -f2-)
    copy_clipboard_content "$description" "$id"
    exit
fi

# Generate list with icons using awk
# Don't delete temp directory - let files accumulate for applications to access
mkdir -p "$tmp_dir"

read -r -d '' prog <<'EOF'
/^[0-9]+\s*<meta http-equiv=/ { next }
match($0, /^([0-9]+)\s*\[\[.*binary.*data.*(image\/jpeg|image\/jpg|image\/png|image\/bmp|image\/gif|image\/webp|image\/tiff|image\/svg|jpg|jpeg|png|bmp|gif|webp|tiff|svg)/, grp) {
    # Extract file extension from mime type or direct extension
    ext = "png"  # default
    if (match(grp[2], /(jpeg|jpg)/)) ext = "jpg"
    else if (match(grp[2], /png/)) ext = "png"
    else if (match(grp[2], /gif/)) ext = "gif"
    else if (match(grp[2], /bmp/)) ext = "bmp"
    else if (match(grp[2], /webp/)) ext = "webp"
    else if (match(grp[2], /tiff/)) ext = "tiff"
    else if (match(grp[2], /svg/)) ext = "svg"
    
    system("echo -n " grp[1] " | cliphist decode > " ENVIRON["tmp_dir"] "/" grp[1] "." ext)
    print $0 "\0icon\x1f" ENVIRON["tmp_dir"] "/" grp[1] "." ext
    next
}
match($0, /^([0-9]+)\s*file:\/\/(.+\.(jpg|jpeg|png|bmp|gif|webp|tiff|svg))$/, grp) {
    if (system("test -f \"" grp[2] "\"") == 0) {
        print $0 "\0icon\x1f" grp[2]
    } else {
        print $0 "\0icon\x1fimage-x-generic"
    }
    next
}
1
EOF

export tmp_dir
cliphist list | gawk "$prog" 